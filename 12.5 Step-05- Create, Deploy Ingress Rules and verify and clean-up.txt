# 12.5 Step-05- Create, Deploy Ingress Rules and verify and clean-up

-: Welcome back.As part of step seven,we are going to define the ingress manifestwith ingress rules.So before going there,we need to understand ingress path types in detail.So if we go here,we have three types of path types available for usfrom ingress perspective.So one is implementation-specificand second is exact path type matchand the third one is prefix match.So implementation-specific.Implementation-specific path type is nothingbut further respect to controller.So with this path type,matching is up to the controllerimplementing the ingress class.So example, we are using the AWSALB-related ingress controller,and in this implementation,if we have any specific path types defined related to AWS,so we can use with implementation-specific.And by default it is going to be implementation-specificif we don't define the path type argumentin our respective rules.So implementation can treat thisas a separate path type or treat it identicallyto either prefix or even the exact path types.And exact is nothing but it need to match exact URL pathwith the case sensitivity.And prefix is nothing but matches based on a URL path,prefix split by slash.Matching is case-sensitiveand done on a path element-by-element basis.So if we take the examples,we'll get the clarity on prefix and then exact.And implementation-specific will be by default.But as we said here, so it might considerto consider it as either prefix or exactbased on the implementation that controller is implemented.So we are going to use prefix, why?Because which is loosely coupled and easily we can use it.So let's take the examples hereand understand more about it,the differences between the prefix and the exactand then how it is going to work.So example in prefix, right?You have defined in your Kubernetes manifest as slash.So in the request path,whenever you are accessing by a browser,all parts are allowed.That's the reason it says matches yes,which means this is true, it works.So whenever you define slash with path type as prefix,all paths are allowed.And the next thing is exact.So whenever you provide the path type as exact.So before going and implementing these things,so let's see this here, right?So in the rules, http paths, you can see path,whatever the path you define,and the path type is prefix are exact.So like this you are going to define the stuff,so let me copy this, right?And come back to our ingress manifest, right?So where is it?In zero to kube manifesto rulesand in ALB ingress basic.So API version, kind, metadata annotation,all are same as previous ingress manifest, right?Bill spec and ingress class name.So only thing now we are defining here is rules.Under rules, we are defining the http rules,and under that, you have the paths,and the path we are going to use is root, right?Which means all paths should be allowedand path type is prefix and backend.In backend, the service name we need to provideis so we'll go to hereand this is same as, again, 0101,which is NGINX app one deployment and NodePort service.It is absolutely same.So I'll bring that from there and come back hereand provide the name here and number is 80, right?So once we have defined this,so now let's go back hereand understand more about these things.So you set slash so that all parts are allowed,so which means whenever you access with /app1/index.html,it is going to work for us without any issue.So now let's come back hereand if you define here in the path /fu, right?And if you access it with /fu from your browser, right?So http://somestacksimplify.com/fu,and you also define here the fu,so then it is going to work.And when you define it as exact, right?In the same way, whenever you define it as exactand when you define it as fu,and when you access it as bar and it is going to fail.So that's the thing.So like this, we need to understand this is the request pathwhich is nothing but from the browserwhatever you are accessingand this is like whatever you are defining hereand the kind is nothing but the path type you are defining.So for us, I'll roll back this one to this oneand I will remove this, okay?And now, let's see.Same thing for exact/fu and then you'll accesswith adding the trailing slash,again it is going to failbecause exact is exact, that's all.And exact/fu/ if you access and with only /fufrom the request path which is from the browser,then it is also going to fail.So which means exactis only for critical specific implementationswhich you know thoroughly, right?But most of the time, prefixes loosely coupledand you'll be able to easily use it, right?If you see /fu works for /fuand also with trading/ also it works.And here also with prefix with trading/ if you put itand in your path if you define /fu/ with the trailing slash,still it is going to workwith and without when you access it via browser.And prefix with /aaa/bbband if you try to access with additional B here,it is not going to work, why?Because it is not going to add any string editions here.It is like /aabb and it should be /aabb.That's all, right?But if you provide /aaa/bbb,and also if you request via browser also /aaa/bbb,it is going to work.So like this, you can define.You can see all these things how it is going to be,all the samples provided here.So these are generic ingress things,prefix whatever you see and for exact also.So you can define these things,and accordingly, most of the things are covered here.So you can use it and then implement your rules.So now let's come back here, remove this,and the path is slash, prefix, backend,and everything is good.So now let's go back to our GitHub, right?And then run the kubectl apply now.So let's come back here.And we are in 0802 ALB ingress basics.And if you see here,we should have something called 01and then 02 related folders, right?01 and 02.So I'll say kubectl apply-F zeroto kube manifest rules, right?So this should create the NGINX deploymentand NGINX service and NGINX ingress service, right?So now we can go ahead and then see kubectl portsand our app one NGINX port is created,and if we run the SVC,it should provide us the app one NGINX NodePort servicewhich is 30, 134 is the NodePort service,and we'll also run the kubectl get ingress,and you can see ingress NGINX one is createdand this is the URL for that.And let's go here to load balances, refresh, right?And you can see the name of it is app one ingress rules.So why?Because I have given the name for this as ingress rules.This is a ingress rules demo.So the load balancer name,I have given as app one ingress rules, right?And here are the listenersand it is in the state as provisioning.If you go to target group and open that, right?So you can find both the worker nodes were registered herewith port 30134, so whatever we have defined here, right?So 30134, whatever it has automatically generatedfor this NodePort service.So now let's wait for this load balancerto come to active stateso that we can go ahead and then test it.So we can see here our load balancer is in active state.So we can open hereand we can see there is no default backend for us, right?And we can see path/starand for the /star goesto our app one NGINX default target group,and inside the target group,we have our respecting NodePort servicerelated things registered, right?So both nodes were registered with 30134, right?So now let's see.Both are healthy.So now let's come back hereand take this, copy, and run this, right?And you should seethat we should get the welcome to NGINX root context page.Why? Because we said /tar.And I'll also say /app1/index.html,and my app one should be accessible now.So let me close these things, right?So now what we are going to dois we are going to also verify cubectl, describe ingress,and ingress name is ingress NGINX app one.And we'll see there are rules here,how it is defined, right?So let's wait for it.See the default backend is default backend httpand nothing is there here in the default backend.And in the rules, you can see for the slash,this is the NodePort service it is pointed to.So this is the differencebetween the previous default backend one.There you have seen the NodePort service hereand now you are seeing the NodePort service herefor the half one NGINX.So this is good.Now what we are going to do is we'll do a small test.Even I didn't document that step here,but we will do that, right?So let's come back here and in zero, add zero two, right?We will change this to /app1.So we have learned about that prefix things a lot here,if you remember, right?So let me open this documentation, ingress path types,and we have defined /app1,which means earlier whatever we are accessing here.So let's come back here and this should go away,which means whatever the root contextunder the root context,whatever we are accessing this welcome to NGINX page.So after this change, it should go away.So let's see.So we are seeing that only anything with /app1,then only go to app one NGINX NodePort service.So which means under the root context,whatever is there, it should fail, right?So now we have saved thisand if you come back hereand see /fu with prefix, it will allow for /fu,and anything with /fu/star, right?So that is the importance of prefix.So let me run this change now.So I'll come back, kubectl, apply-F,and then zero to kube manifest rules.And this change should take place.And now if I say kubectl,describe ingress, ingress NGINX app one,so you should see the rules here, which is /app1.And if you go back hereto rules here and refresh them, right?Or if you go here,so it should say /app1 or /app1/star.So now let's come back here.Kubectl, get ingress, right?And copy this, right?And go to the browser and try it.So this is coming from the cash.So let me go here.See, it is failing in the incognito window.And if I say /app1 and it should,app1/index.html, so this should work.So very clearly tested the use casewhich we have discussed here, which is this one.Parts/fu, so /fu and then /fu will be allowedwhen your path type is of kind prefix.So let me roll back this change hereso that you can test it later, right?So with default one.So now let's come back hereand go ahead and then clean up.So I'll come back here and clean up.Kubectl, delete-F 02 kube manifest rules.So this should remove the deployment serviceand also the ingress servicewhich is the application load balancer,whatever it has created.So let's wait for all the resources to get deleted.So one important thing to note here is verifywhether your ingress is deleted successfully or not, why?Because application load balancer is costly,and by any chance, if it didn't get deleted properly,then it is going to charge us heavily, right?So for that purpose,verify with getting less command here, kubectl get ingress,and also go hereand also say refresh in your load balances sectionand also verify there are no load balancesso that we'll not have any unexpected charges for us.So I'll see you in the next lecture.Until then, bye-bye.Thank you.