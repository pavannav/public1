Welcome back, and in this lesson I want to quickly cover a pretty advanced feature of auto-scaling groups,
and that's auto-scaling group lifecycle hooks.
So let's jump in and take a look at what these are and how they work.
So lifecycle hooks allow you to configure custom actions which can occur during auto-scaling group actions.
So you can define actions which occur either during instance launch transitions or instance terminate transitions.
So what this allows you to do is when an auto-scaling group scales out or scales in,
it will either launch or terminate instances.
And normally this process is completely under the control of the auto-scaling group,
so as soon as it makes a decision to provision or terminate an instance,
this process happens with no ability for you to influence the outcome.
What lifecycle hooks do is when you create them, instances are paused within the launch or terminate flow,
and they pause or wait in this state until one of two things happen,
either a configurable timeout, and when that timeout expires, which by default is 3600 seconds,
they will either continue or abandon the auto-scaling group action.
The alternative is whatever process that you perform,
you can explicitly resume the process using complete lifecycle action
once you've performed whichever activity you want to perform.
Now in addition to this, lifecycle hooks can either be integrated with event bridge or SNS notifications,
which allow your systems to perform event-driven processing
based on the launch or termination of EC2 instances within an auto-scaling group.
So let's look at how this looks visually.
So let's start with a simple auto-scaling group.
If we configure instance launch and terminate hooks, this is what it might look like.
So normally when an auto-scaling group gets a scale out situation,
an instance will be launched and it starts off in the pending state.
When it completes, it will move into the in-service state,
but this gives us no opportunity to perform any custom activities.
What we could do is define a lifecycle hook and hook into the instance launch transition.
So if we do hook into this transition, the instance would move from pending to pending wait,
and it would wait in this state.
This allows us to perform a set of custom actions.
An example might be to load or index some data which might take some time,
and during this time the instance stays in this state.
Once done, it will move from a pending wait state to a pending proceed state,
and from there it would move into the in-service state.
So this is the process when configuring a lifecycle hook for this part of an EC2 instances lifecycle.
It's these extra steps, the wait and proceed, which allows the opportunity to run custom actions,
and the same happens in reverse if we define an instance terminate hook.
What would normally happen when a scaling event happens
would be the instance would move from a terminating state to a terminated state,
and again, we wouldn't have the ability to perform any custom actions.
Well, what we could do is define a lifecycle hook to hook into that.
Instead, the instance would move from terminating to terminating wait,
where it would wait for a timeout.
Now, by default, this is 3600 seconds, and it would wait at this point,
or until we ran the complete lifecycle action operation.
We could use this time period to maybe back up some data or logs,
or otherwise tidy up the instance prior to its termination.
And once the timeout expired, or when we explicitly call complete lifecycle action,
then it would move from terminating wait to terminating proceed,
and then finally through to the terminated state.
Now, lifecycle hooks can integrate, as I mentioned previously,
with SNS for transition notifications,
and EventBridge can also be used to initiate other processes based on the hooks in an event-driven way.
Now, that's everything I wanted to cover about lifecycle hooks,
so at this point, go ahead and complete this lesson,
and when you're ready, I'll look forward to you joining me in the next.
