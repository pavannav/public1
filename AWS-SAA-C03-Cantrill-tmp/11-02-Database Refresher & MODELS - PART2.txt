Welcome back, this is part two of this lesson. We're going to continue immediately from the end of part one, so let's get started.
Now there are other types of database platforms, NoSQL platforms, and this doesn't represent one single way of doing things.
So I want to quickly step through some of the common examples of NoSQL databases, or non-relational databases.
The first type of database in the NoSQL category that I want to introduce is Key Value Databases.
The title gives away the structure. Key Value Databases consist of sets of keys and values.
There's generally no concept of structure, it's just a list of keys and value pairs.
In this case, it's a Key Value Database for one of the Animals for Life rescue centers.
It stores the date and time and a sensor reading from a feeding sensor recording the number of cookies removed from the feeder during the previous 60 minutes.
So essentially the key on the left stores the date and time, and on the right is the number of cookies eaten as detected by the sensor during the previous 60 minutes.
So that's it for this type of database, it's nothing more complex than that, it's just a list of key value pairs.
As long as every single key is unique, then the value doesn't matter.
It has no real schema, nor does it have any real structure because there are no tables or table relationships.
Some Key Value Databases allow you to create separate lists of keys and values and present them as tables,
but they're only really used to divide data, there are no links between them.
And this makes Key Value Databases really scalable, because sections of this data could be split onto different servers.
In general, Key Value Databases are just really fast, it's simple data with no structure,
there isn't much that gets in the way between giving the data to the database and it being written to disk.
For Key Value Databases, only the key matters.
You write a value to a key and you read a value from a key.
The value is opaque to the database, it could be text, it could be JSON, it could be a cat picture, it doesn't matter.
In the exam, look out for any question scenarios which present simple requirements,
or mention data which is just names and values, or pairs, or keys and values.
Look out for questions which suggest no structure.
If you see any of these type of scenarios, then Key Value Stores are generally really appropriate.
And Key Value Stores are also used for in-memory caching.
So if you see any questions in the exam that talk about in-memory caching, then Key Value Stores are often the right way to go.
And I'll be introducing some products later in the course which do provide in-memory Key Value Storage.
Okay, so let's move on.
And the next type of database that I want to talk about is actually a variation of the previous model,
so a variation on Key Value, and it's called a Wide Column Store.
Now, this might look familiar to start with.
Each row or item has one or more keys, generally one of them is called the Partition Key.
And then optionally you can have additional keys as well as the Partition Key.
Now, DynamoDB, which is an AWS example of this type of database, this secondary key is called the Sort or the Range Key.
It differs depending on the database, but most examples of Wide Column Stores generally have one key as a minimum,
which is the Partition Key, and then optionally every single row or item in that database can have additional keys.
Now, that's really the only rigid part of a Wide Column Store.
Every item in a table has to have the same key layout, so that's one key or more keys, and they just need to be unique to that table.
Wide Column Stores offer groupings of items called tables, but they're still not the same type of tables as in relational database products.
They're just groupings of data. Every item in a table can also have attributes.
But, and this is really important, they don't have to be the same between items.
Remember how in relational database management systems, every table had attributes, and then every row in that table had to have a value for every one of those attributes.
That is not the case for most NoSQL databases, and specifically Wide Column Stores, because that's what we're talking about now.
In fact, every item can have any attribute. It could have all of the attributes, so all of the same attributes between all of the items.
It could have a mixture, so mix and matching attributes on different items, or an item could even have no attributes.
There is no schema, no fixed structure on the attribute side. It's normally partially opaque for most database operations.
The only thing that matters in a Wide Column Store is that every item inside a table has to use the same key structure, and it has to have a unique key.
So whether that's a single partition key, or whether it's a composite key, so a partition key and something else, if it's a single key, it has to be unique.
If it's a composite key, the combination of both of those values has to be unique.
That's the only rule for placing data into a table using Wide Column Stores.
Now, DynamoDB inside AWS is an example of this type of database, so DynamoDB is a Wide Column Store.
Now, this type of database has many uses. It's very fast, it's super scalable, and as long as you don't need to run relational operations such as SQL commands on the database,
it often makes the perfect database product to take advantage of, which is one of the reasons why DynamoDB features so heavily amongst many web scale or large scale projects.
Okay, so let's move on, and next I want to talk about a document database, and this is a type of NoSQL database that's designed to store and query data as documents.
Documents are generally formatted using a structure such as JSON or XML, but often the structure can be different between documents in the same database.
You can think of a document database almost like an extension of a key value store where each document is interacted with via an ID that's unique to that document,
but the value, the document contents, are exposed to the database allowing you to interact with it.
Document databases work best for scenarios like order databases or collections or contact style databases, situations where you generally interact with the data as a document.
Document databases are also great when you need to interact with deep attributes, so nested data items within a document structure.
The document model works well with use cases such as catalogs, user profiles, and lots of different content management systems where each document is unique but it changes over time,
so it might have different versions, documents might be linked together in hierarchical structures, or when you're linking different pieces of content in a content management system.
For any use cases like this, document style databases are perfect. Each document has a unique ID and the database has access to the structure inside the document.
Document databases provide flexible indexing so you can run really powerful queries against the data that could be nested deep inside a document.
Now let's move on. Column databases are the next type of database type that I want to discuss,
and understanding the power of these databases requires knowing the limitations of their counterpart, row-based databases, which is what most SQL-based databases use.
Row-based databases are where you interact with data based on rows.
So in this example we have an orders table, it has order ID, the product ordered, color, size, and price. For every order we have a row, and those rows are stored on disk together.
If you needed to read the price of one order from the database, you read the whole row from disk. If you don't have indexes or shortcuts, you'll have to find that row first,
and that could mean scanning through rows and rows of data before you reach the one that you want to query.
Now if you want to do a query which operates over lots of rows, for example you wanted to query all of the sizes of every order, then you need to go through all of the rows, finding the size of each.
Row-based databases are ideal when you operate on rows. Creating a row, updating a row, or deleting rows.
Row-based databases are often called OLTP, or Online Transaction Processing Databases, and they are ideal as the name suggests for systems which are performing transactions.
So order databases, contact databases, stock databases, things which deal in rows and items, where these rows and items are constantly accessed, modified, and removed.
Now column-based databases handle things very differently. Instead of storing data in rows on disk, they store it based on columns.
The data is the same, but it's grouped together on disk based on column. So every order value is stored together, every product item, every color, size, and price, all grouped by the column that the data is in.
Now this means two things. First, it makes it very, very inefficient for transaction style processing, which is generally operating on whole rows at a time.
But this very same aspect makes column databases really good for reporting.
So if your queries relate to just one particular column, because that whole column is stored on disk grouped together, then that's really efficient.
You could perform a query to retrieve all products sold during a period, or perform a query which looks for all sizes sold in total ever, and looks to build up some intelligence around which are sold most and which are sold least.
With column store databases, it's really efficient to do this style of querying, reporting style querying.
An example of a column-based database in AWS is Redshift, which is a data warehousing product, and that name gives it away.
Generally, what you'll do is take the data from an OLTP database, a row-based database, and you'll shift that into a column-based database when you're wanting to perform reporting or analytics.
So generally, column store databases are really well suited to reporting and analytics.
Now lastly, I want to talk about graph style databases.
Earlier in the lesson, I talked about tables and keys and how relational database systems handled relationships by linking the keys of different tables.
Well, with graph databases, relationships between things are formally defined and stored in the database itself along with the data.
They're not calculated each and every time you run a query, and this makes them great for relationship-driven data, for example, social media or HR systems.
Consider this data, three people, two companies, and a city.
These are known as nodes inside a graph database, nodes and nouns, so objects.
Nodes can have properties which are simple key-value pairs of data, and these are attached to the nodes.
So far, this looks very much like a normal database. Nothing is new so far.
But with graph databases, there are also relationships between the nodes, which are known as edges.
Now these edges have a name and a direction, so Natalie works for XYZ Corp and Greg works for both XYZ Corp and Acme Widgets.
Relationships themselves can also have attached data, so name-value pairs.
In this particular example, we might want to store the start date of any employment relationship.
A graph database can store a massive amount of complex relationships between data or between nodes inside a database, and that's what's key.
These relationships are actually stored inside the database as well as the data.
A query to pull up details on all employees of XYZ Corp would run much quicker than on a standard SQL database,
because that data of those relationships is just being pulled out of the database, just like the actual data.
With a relational-style database, you'd have to retrieve the data, and the relationships between the tables is computed when you execute the query.
So it's a really inefficient process with relational database systems.
These relationships are fixed and computed each and every time a query is run.
With a graph-based database, those relationships are fluid, dynamic, they're stored in the database along with the data,
and it means when you're interacting with data and looking to take advantage of these fluid relationships, it's much more efficient to use a graph-style database.
Now, using graph databases is very much beyond the scope of this course,
but I want you to be aware of it because you might see questions in the exam which mention the technology,
and you need to be able to identify or eliminate answers based on the scenario, based on the type of database that the question is looking to implement.
So if you see mention of social media in an exam or systems with complex relationships, then you should think about graph databases first.
Now that's all I wanted to cover in this lesson. I know it's been abstract and high level.
I wanted to try and make it as brief as possible. I know I didn't really succeed because we had a lot to cover,
but I want this to be a foundational set of theory that you can use throughout the databases section, and it will help you in the exam.
For now though, that's everything I wanted to cover in this lesson.
So go ahead, complete the video, and when you're ready, you can join me in the next.
