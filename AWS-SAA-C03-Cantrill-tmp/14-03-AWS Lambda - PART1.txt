Welcome back, and in this multi-part lesson mini-series, I want to talk about AWS Lambda.
Lambda is a function as a service or a FAS product.
This means that you provide specialized, short-running and focused code to Lambda,
and it takes care of running it and billing you only for what you consume.
So a Lambda function is a piece of code which Lambda runs,
and every Lambda function is using a supported runtime.
So an example of a supported runtime is Python 3.8.
So when you create a Lambda function, you need to define which runtime that piece of code uses.
Now when you provide your code to Lambda, it's loaded into and executed within a runtime environment,
and this runtime environment is specifically created to run code using a certain runtime, a certain language.
So when you create a Lambda function that uses the Python 3.8 runtime,
then the runtime environment that's created is itself specifically designed to run Python 3.8 code.
Now when you create a Lambda function, you also define the amount of resource that a runtime environment is provided with.
So you directly allocate a certain amount of memory,
and based on that amount of memory, a certain amount of virtual CPU is allocated, but this is indirect.
You don't get to choose the amount of CPU, this is based on the amount of memory.
Now the key thing to understand about Lambda as a service,
because it's a function as a service product, because it's designed for short-running and focused functions,
you only actually build for the duration that a function runs.
So based on the amount of resource allocated to an environment,
and based on the duration that that function runs for per invocation,
that determines how much you'll build for the Lambda product.
So you'll build for the duration of function executions.
Now Lambda is a key part of serverless architectures running within AWS,
and over this section of the course you're going to get some experience of how you can use Lambda
to create serverless or event-driven architectures.
Architecturally, the way that Lambda works is this, you define a Lambda function.
Now, you can think of a Lambda function as a unit of configuration.
Yes, you can also use the term Lambda function to describe the actual code,
but when you think of a Lambda function, think of it as the code,
plus all the associated wrappings and configuration.
Your Lambda function, at its most basic, is a deployment package which Lambda executes.
So when you create a Lambda function, you define the language which the function is written in,
you provide Lambda with a deployment package, and you set some resources.
So whenever the Lambda function is invoked, what actually happens is the deployment package is downloaded
and executed within this runtime environment.
Now Lambda supports lots of different runtimes.
Some of the common ones are various different versions of Python,
we also have Ruby, we've got Java, we've also got Go, and there's also C Sharp,
as well as various versions of Node.js.
Now you can also create custom ones using Lambda layers,
and many of these are created by the community.
For the exam though, one really important point is that if you see or hear the term Docker,
consider this to mean not Lambda, so Docker is an anti-pattern for Lambda.
Now Lambda does now support using Docker images, but this is distinct from the word Docker.
If you hear the term Docker in the exam, then it generally will be referring to traditional containerized computing.
So that's using a specific Docker image to spin up a container,
and use it in a containerized compute environment such as ECS.
Now you can also use container images with Lambda.
Now that's a different process, that means that you're using your existing container build processes,
the same ones that you use to create Docker images, but instead you're creating specific images
designed to run inside the Lambda environment.
So don't confuse Docker container images and Docker with images used for Lambda.
They're two different things.
The only thing that they share is that you can use your existing build processes to build Lambda images.
Now custom runtimes could allow languages such as Rust,
which is a very popular community-based language, to work within the product.
So if you search using Google or any other popular search engine,
you'll be able to find lots of languages which have been added by the community
using the Lambda layer functionality, and I'll be talking about that elsewhere in the course.
Now you select the runtime to use when creating the function,
which determines the components which are available inside the runtime environment.
So Python code, for instance, requires Python of a certain version to be installed
in addition to various Python modules.
Conceptually, think about it like this, every time a Lambda function is invoked,
which means to execute that function, a new runtime environment is created
with all of the components that that Lambda function needs.
For example, a Python 3.8-based Lambda function.
So the code loads, it's executed, and then it terminates.
Next time a new clean environment is created, it does the same thing, and then it terminates.
Lambda functions are stateless, which means no data is left over from a previous invocation.
Every time a function is invoked, it's a brand new invocation, a brand new environment.
Now I'm going to be talking about this in part three of this series,
because this isn't always the case, but you have to assume that it is architecturally.
So your code running within Lambda needs to be able to work 100% of the time,
if it's a new environment. Lambda runtime environments have no state.
Now there are some situations where a function might be invoked multiple times within the same environment,
and I'll be talking about that in part three of this series,
but as a base level, a default, assume that every time a Lambda function is invoked,
it's inside a brand new runtime environment.
Now you also define the resources that Lambda functions use,
and this determines how much resource the runtime environment gets.
Now you directly define the memory, and this is anywhere from 128 MB
to 10240 MB in one MB steps.
Now you don't directly control the amount of virtual CPU,
this scales with the memory.
So 1769 MB of memory gives you one vCPU of allocation, and it's linear.
So the less memory means less virtual CPUs, and more memory means additional vCPU capacity.
The runtime environment also has some disk space allocation,
512 MB is mounted as forward slash TMP within the runtime environment.
This is the default amount, but it can scale to 10240 MB.
Now you can use this, but keep in mind this should only be viewed as temporary space.
Lambda functions can run for up to 900 seconds or 15 minutes,
and this is known as the function timeout.
This is important because for anything beyond 15 minutes you can't use Lambda directly,
and that's a really important figure to know for the exam.
You know by now I'm not a fan of people memorizing facts and figures,
but this is definitely one that you need to remember for the exam.
So 15 minutes is a critical amount of time for a Lambda function.
You can use other things such as step functions to create longer running workflows,
but one invocation of one function has a maximum of 15 minutes or 900 seconds.
Now we're going to be covering security in more detail in part two, as well as networking,
but the security for a Lambda function is controlled using execution roles,
and these are IAM roles assumed by the Lambda function,
which provides permissions to interact with other AWS products and services.
So any permissions which a Lambda function needs to be provided with
are delivered by creating an execution role and attaching that to a specific Lambda function.
Now just a few final things before we finish up some common uses of Lambda.
So Lambda forms a core part of the delivery of serverless applications within AWS,
and generally this uses products such as S3, API Gateway, and Lambda.
So these three together are often used to deliver serverless applications.
Lambda can also be used for file processing using S3, S3 events, and Lambda.
So a very common example that's used in training is watermarking images.
So have images uploaded to S3, generate an S3 event,
invoke a Lambda function which applies a watermark, and then terminates,
and you're only billed for the compute resources used during those Lambda function invocations.
You can also use Lambda for database triggers,
so this is using DynamoDB as well as DynamoDB Streams, and then Lambda.
So Lambda can be invoked any time data is inserted, modified, or deleted
from a DynamoDB table with Streams enabled, and this is another powerful architecture.
You can also use Lambda to implement a form of serverless cron,
so you can use EventBridge or CloudWatch events to invoke Lambda functions
at certain times of day or certain days of week to perform certain scripted activities,
and this is something that traditionally you would need to run on something like an EC2 instance,
but using Lambda means that you're only billed for the amount of time that these functions are executing,
so this is another really common use case.
And then finally, you can perform real-time stream data processing,
so Lambdas can be configured to invoke whenever data is added to a Kinesis stream,
and this can be useful because Lambda is really scalable,
and so it can scale with the amount of data being streamed into a Kinesis stream.
And again, this is another really common architecture for any businesses
that are streaming large quantities of data into AWS,
and they require some form of real-time processing.
Now that's everything that I wanted to cover in part one of this series.
Remember, it's a three-part mini-series.
Part two and part three are going to introduce some more advanced concepts,
specifically those that you'll need for the exam.
But at this point, go ahead, complete this lesson,
and then when you're ready, I'll look forward to you joining me in the next.
