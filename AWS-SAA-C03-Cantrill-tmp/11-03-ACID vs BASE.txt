Welcome to this lesson where I want to provide a really quick theoretical introduction to ACID and BASE which are two database transaction models that you might encounter in the exam and in the real world.
Now this might seem a little abstract but it does feature on the exam and I promise in real world usage knowing this is a database superpower.
So let's jump in and get started.
ACID and BASE are both acronyms and I'll explain what they stand for in a moment but they are both database transaction models.
They define a few things about transactions to and from a database and this governs how the database system itself is architected.
At a real foundational level there's a computer science theorem called the CAP Theorem and it stands for Consistency, Availability and Partition Tolerance.
Now let's explore each of these quickly because they really matter.
Consistency means that every read to a database will receive the most recent write or it will get an error.
On the other hand availability means that every request will receive a non-error response but without the guarantee that it contains the most recent write and that's important.
Partition Tolerance means that the system can be made of multiple network partitions and the system continues to operate even if there are a number of dropped messages or errors between these network nodes.
Now the CAP Theorem states that any database product is only capable of delivering a maximum of two of these different factors.
One reason for this is that if you imagine that you have a database with many different nodes, all of these are on a network, imagine if communication fails between some of the nodes or if any of the nodes fail.
Well you have two choices if somebody reads from that database.
You can cancel the operation and thus decrease the availability but ensure the consistency or you can proceed with the operation and improve the availability but risk the consistency.
So as I just mentioned it's widely regarded as impossible to deliver a database platform which provides more than two of these three different elements.
So if you have a database system which has multiple nodes and if a network is involved then you generally have a choice to provide either consistency or availability and the transaction models of ACID and BASE choose different trade-offs.
ACID focuses on consistency and BASE focuses on availability.
Now there is some nuance here and some additional detail but this is a high level introduction. I'm only covering what's essential to know for the exam.
So let's quickly step through the trade-offs which each of these makes and we're going to start off with ACID.
ACID means that transactions are atomic, transactions are also consistent, transactions are also isolated and then finally transactions are durable.
And let's get the exam power up out of the way. Generally if you see ACID mentioned then it's probably referring to any of the RDS databases.
These are generally ACID based and ACID limits the ability of a database to scale and I want to step through some of the reasons why.
Now I'm going to keep this high level but I've included some links attached to this lesson if you want to read about this in additional detail.
In this lesson though I'm going to keep it to what is absolutely critical for the exam.
So let's step through each of these individually.
Atomic means that for a transaction either all parts of a transaction are successful or none of the parts of a transaction are successful.
Consider if you run a bank and you want to transfer $10 from account A to account B.
That transaction will have two parts. Part one will remove $10 from account A and part two will add $10 to account B.
Now you don't want a situation where the first part or the second part of that transaction can succeed on its own and the other part can fail.
Either both parts of a transaction should be successful or no parts of the transaction should be applied and that's what atomic means.
Now consistent means that transactions applied to the database move the database from one valid state to another.
Nothing in between is allowed.
In databases such as relational databases there may well be links between tables where an item in one table must have a corresponding item in another.
Where values might need to be in certain ranges.
And this element just means that all transactions need to move the database from one valid state to another as per the rules of that database.
Isolated means that because transactions to a database are often executed in parallel they need not to interfere with each other.
Isolation ensures that concurrent executions of transactions leave the database in the same state that would have been obtained if transactions were executed sequentially.
So this is essential for a database to be able to run lots of different transactions at the same time.
Maybe from different applications or different users.
Each of them need to execute in full as they would do if they were the only transaction running on that database.
They need not to interfere with each other.
And then finally we have durable which means that once a transaction has been committed it will remain committed even in the case of a system failure.
Once the database tells the application that the transaction is complete and committed.
Once it's succeeded that data is stored somewhere that system failure or power failure or the restart of a database server or node won't impact the data.
Now most relational database platforms use ACID based transactions.
It's why financial institutions generally use them because it implements a very rigid form of managing data and transactions on that data.
But because of these rigid rules it does limit scalability.
Now next we have base and base stands for basically available.
It also stands for soft state and then lastly it stands for eventually consistent.
And again this is super high level and I've included some links attached to this lesson with more information.
Now it's also going to sound like I'm making fun of this transaction model because some of these things seem fairly odd.
But just stick with me and I'll explain all of the different components.
Basically available means that read and write operations are available as much as possible but without any consistency guarantees.
So reads and writes are kinder or maybe.
Essentially rather than enforcing immediate consistency base modeled NoSQL databases will ensure availability of data by spreading and replicating that data across all of the different nodes of that database.
There isn't really an aim within the database to guarantee anything to do with consistency.
It does its best to be consistent but there's no guarantee.
Now soft state is another one which is a tiny bit laughable in a way.
It means that base breaks off with the concept of a database which enforces its own consistency.
Instead it delegates that responsibility to developers.
Your application needs to be aware of consistency and state and work around the database.
If you need immediate consistency, so if you need a read operation to always have access to all of the writes which occurred before it immediately
and if the database optionally allows it then your application needs to specifically ask for it.
Otherwise your application has to tolerate the fact that what it reads might not be what another instance of that application has previously written.
So with soft state databases your application needs to deal with the possibility that the data that you're reading isn't the same data that was written moments ago.
Now all of these are fairly fuzzy and do overlap but lastly we have the fact that base does not enforce immediate consistency.
It means that it might happen eventually.
If we wait long enough then what we read will match what has been previously written eventually.
Now this is important to understand because generally by default a base transaction model means that any reads to a database are eventually consistent.
So applications do need to tolerate the fact that reads might not always have the data for previous writes.
Many databases are capable of providing both eventually consistent and immediately consistent reads
but again the application has to have an awareness of this and explicitly ask the database for consistent reads.
Now it sounds like base transactions are pretty bad right?
Well not really. Databases which use base are actually highly scalable and can deliver really high performance
because they don't have to worry about all the pesky annoying things like consistency within the database.
They offload that to the applications.
Now DynamoDB within AWS is an example of a database which normally works in a base-like way.
It offers both eventually and immediately consistent reads but your application has to be aware of that.
Now DynamoDB also offers some additional features which offer acid functionality such as DynamoDB transactions.
So that's something else to keep in mind.
Now for the exam specifically I have a number of useful defaults.
If you see the term base mentioned then you can safely assume that it means a NoSQL style database.
If you see the term acid mentioned then you can safely assume as a default that it means an RDS database.
But if you see NoSQL or DynamoDB mentioned together with acid then it might be referring to DynamoDB transactions
and that's something to keep in mind.
Now that's everything I wanted to cover in this high level lesson about the different transaction models.
This topic is relatively theoretical and pretty deep and there's a lot of extra reading.
But I just wanted to cover the essentials of what you need for the exam.
So I've covered all of those facts in this lesson and at this point it is the end of the lesson.
So thanks for watching, go ahead and complete the video and then when you're ready I'll look forward to you joining me in the next.
Thanks for watching.
