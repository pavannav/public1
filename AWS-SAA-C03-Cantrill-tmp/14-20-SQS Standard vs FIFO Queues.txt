Welcome back, and in this lesson I want to quickly step through the differences between
standard SQSQs and FIFO SQSQs, so let's quickly jump in and get started.
To get started with understanding some of the architectural differences between standard
and FIFO Qs, I want you to think about FIFO Qs as single lane highways, and then think
about standard Qs as multi-lane highways.
Imagine the messages as cars driving along these highways.
What this means is that the performance of a FIFO Q, so the number of cars per second
in this analogy, and the number of messages per second in reality, is limited by the width
of the road.
FIFO Qs can handle 300 messages per second without batching, and 3000 with.
Now this is actually 300 transactions per second to the SQS API when using FIFO mode.
Each transaction is one message, but with batching it means that each transaction can
contain 10 messages.
Now it's worth mentioning at this point that there is a high throughput mode for FIFO,
but at the time of creating this lesson it's only available in preview.
Standard Qs, so multi-lane highways in this analogy, don't suffer from any real performance
issues, and can scale to a near infinite number of transactions per second.
FIFO Qs, as the name suggests, guarantees order, they're first in, first out.
So what you're trading is performance for this preserved order.
They also guarantee exactly once processing, removing the chance of duplicate message delivery.
Now another odd restriction is that FIFO Qs have to have a FIFO suffix in order to be
a valid FIFO Q. Now remember that one because I've seen it come up in the exam many times
before.
Now FIFO Qs are great for workflow based order processing, command ordering, so if you've
got a system administrator who's entering commands into a processing system and you
need the order of those commands to be maintained, then FIFO Qs are ideal, as well as any sequential,
iterative price adjustment calculations for sales order workflows.
Now standard Qs, so the multi-lane highways of Qs, they're faster.
Conceptually think of this as multiple messages being carried on the highway at the same time,
so the multi-lane part of this analogy.
But because of this there are a few important trade-offs.
First, there's no rigid preservation of message ordering, it's best efforts only.
And second, what's guaranteed is only at least once message delivery, meaning in theory
messages can be delivered more than once.
So any applications which use standard Qs need to be able to accommodate the potential
for multiple of the same messages to be delivered.
Now standard Qs are ideal for decoupling application components, or for workable architectures,
or to batch together items for future processing, so all of these are ideal use cases for standard
SQSQs.
Now that's everything I wanted to cover, I just wanted to make sure that for the exam
you understand the difference in architecture between these two different Q types.
Thanks for watching, go ahead and complete the lesson, and when you're ready I'll look
forward to you joining me in the next.
