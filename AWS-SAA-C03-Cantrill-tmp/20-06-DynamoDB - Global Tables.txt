Welcome back, and in this lesson, I want to talk about DynamoDB Global Tables,
something which will form part of your toolkit as a solutions architect for any global database deployments.
Now, this lesson will be entirely based around architectural theory, so let's jump in and get started.
Global Tables aren't actually that complex. They provide multi-master replication,
meaning no single table is viewed as the master and others are replicas.
Instead, all tables are the same. It's global and allows for read and write replication
between all tables that are part of a global table.
To implement global tables, you create tables in multiple AWS regions,
and then on one of the tables, it doesn't matter which, you configure the links between all of the tables.
This creates a global table and sets DynamoDB to configure replication between all of the table replicas.
So tables become table replicas of a global table.
So think of a global table as an entity by itself, and supporting that global table
are individual DynamoDB tables in different AWS regions configured for multi-master replication.
Now, between the tables, DynamoDB utilizes last-writer wins for conflict resolution
because it's simple and generally it generates entirely predictable outcomes.
So in the event that you've got the same piece of data being written to two different tables at around the same time,
then DynamoDB will pick the most recent write and it will replicate that to all of the other replica tables
that are part of the global table. So whichever is the most recent will overwrite everything else.
Now, because it's multi-master, it means that you can read and write to any region
and the updates are replicated to all other regions, generally within a second.
Now, it's really fast and that matters because it means that it can be used for more demanding applications.
In terms of consistency, you can perform strongly consistent reads in the same region
as data is written to, but for anything else, it's always eventual consistency.
The replication between tables is asynchronous, and so if you have a global application,
it needs to be able to tolerate eventual consistency.
If you have a global table and one of the replica tables is in the US and one of them is in London,
if you're writing to one and reading from the other, it will always be eventual consistency.
And so your application needs to take that into account.
If it can't cope with eventual consistency, then global tables are going to be problematic.
Now, to use global tables, you first need to select the AWS regions which will be part of that global table.
For example, we could use one of the US regions, AP Southeast 2 in Australia, and the London region.
Then in each of those regions, you'd create a DynamoDB table.
You would select one of the tables, it doesn't matter which, but let's use the US in this example.
And from that table, we would add all of the tables into the global table configuration.
And this would establish the multi-master replication between all three tables.
So all three tables can support reads and writes.
Now, specifically for the exam, you don't really need to be aware of the implementation details.
The architecture is what matters.
So be aware that replication is generally sub-second.
This depends somewhat on the load on each of the different regions, but generally it does occur within a second.
Now, globally, as I mentioned moments ago, it's eventually consistent,
but you can do eventual or strongly consistent reads as long as it's in the same region.
The replication is multi-master, which means that all regions can be used for both read and write operations.
And finally, in terms of what this architecture supports,
well, if you want to implement a globally highly available application,
or you want to improve the global data performance of an application,
or you want to add global disaster recovery or business continuity capability to your application,
then global tables can support all of those requirements.
It's a feature which is really simple to use, but it's highly effective.
And as long as you're aware that the conflict resolution is last write or wins,
and your application is able to tolerate that, then you can use the feature to support a global data layer for your application.
It's a really good feature to implement as long as your application can tolerate all of the requirements.
So at this point, go ahead, complete this video, and when you're ready, I'll look forward to you joining me in the next.
