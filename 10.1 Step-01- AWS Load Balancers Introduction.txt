# 10.1 Step-01- AWS Load Balancers Introduction

-: Welcome back.In this lecture, we are going to primarily lookinto classic load balancer implementation on Kubernetes.But, before going to understandabout classic load balancer implementation using Kubernetes,so, let's see on a very high level,what is elastic load balancing in AWS.So, in AWS, we have three types of load balancers availablefor providing the high availability for our applications.So, those are classic load balancers,network load balancers, and then application load balancers.So, to see in detail about all these three things,in a feature by feature comparison manner,we have this link available for us.And then instead of a slide with all these features,AWS has documented it super,so we can directly see on the AWS documentation page.So we can see here, application load balancer,network load balancer, and then classic load balancer.So the protocols, each one supports is,application load balancer is a HTTP and HTTPS level only.And network load balancer is a TCP, UDP,and then TLS protocols, it supports.And classic load balancer supportsboth TCP, HTTP, HTTPS, and SSL.One important thing we need to understandabout classic load balancersis this is a legacy load balancerwhich is going to get deprecated anytime in the near future.But, another important thingabout this in Kubernetes format,is like in relation with Kubernetes is,whenever we create a service in Kubernetes, right,the service object in Kubernetes,and of type load balancer,the default load balancer it is going to create on AWSis classic load balancer.So that's the important thing we need to know.And in addition to that we'll have platforms,like as it is legacy,it also supports the EC2 classic environment,and also latest VPC environments.So these are new oneswhich all supports directly the VPC environments,which is nothing but Virtual Private Cloud.So like this, there will be tons of features available here.And most of the time,the highest features supported load balanceris going to be application load balancer.If you see here, everything will be tick, tick, tick, tick,and then available for us.So with that said we have a dedicated sectionfor our application load balancer, which is section eight,where we'll be lookinginto creating application load balancer from Kubernetes,and then enabling the SSL for it,and then also enable the port 80 to 443 redirect.So like that,we are going to implement step by step,the entire application load balancerin our section eight.But currently in section seven, whatever we are dealing,we are goingto create a classic load balancer using Kubernetes,and verify the same thing on the AWS management console,how the load balancer got created in AWS management console.In the same way we are goingto create a network load balancer and then test it.So all these things means like,to create a classic load balancer, or network load balancer,we are going to write a service,Kubernetes service manifest,and then verify whether it got created herein EC2 load balancers section.So that's about the thing which we are going to implement.So moving on.So if you see, earlier, what we have done is like with RDS,we have implemented the entire solutionbut what we have done there is like,we have used the NodePort service tool tested, okay?But now in a real production environment, usually,we are not going to use NodePort service, right?It means like IP colon port,we are going to DNS register our URL.And then with URL, we are going to access it.So if that is the case,and we also need to have a port 80 and 443 things, right?Instead of 31, 231, or some other random ports,we need 80 or 443,which are the default browser ports for us, right?So for all those things, let's see,start with using one of the load balancersfor high availability,and then start moving on with the next steps, okay?So now,with this design we are going to add classic load balancerfor our entire previous design, which is nothing but,we have seen this design earlier which is not here.User management NodePort services there.We need to replace this with classic load balancer.So before going and implementing the classic load balancer,we need to understand one important thing here,that is nothing but the EC2 worker nodes,which is nothing but the node group,EKS node group is created in the public subnets here.So, and the cluster control planeis also in the public subnetsand EKS node group is also in the public subnets.So ideally, where in a three tier architecture design,where we deploy our workloads,means like our application codein the private subnets, right?So with that said, now,we are going to create a cluster control plane,means like, which will support the private node groups,means like the node groups created in the private subnets.So let's see that now, right?So in a AWS cloud, in a VPC we have two availability zones.So we created a EKS cluster control plane.So what happens?So it also creates equal and publicand then private subnetsin the availability zoneswhere we have provided to create the cluster, right?So we selected, during the cluster creation,our availability zones for our clusteris going to be one year and then one B.So it created public and private subnetsin those availability zones.So next to what happens is we are goingto create a EKS private node group,which means earlier,you have seen this instances worker nodes presentin public subnet.So now they are presenting private subnet here.So these EC2 instanceswill be created in the private subnet.So now, how the communication is going to happen?Earlier it is in public subnet.It can directly connect to EKS cluster.But if it is in private subnet,it is going to leverage the NAT gateway to communicate it,provided, if our API cluster control planes API,Kubernetes API is having the public access,even we can have it enabled internal,which is direct VPC access.Wherein instead of going via a NAT gateway,this connection can be directly to cluster control plane.Okay?When we do via VPC access, okay?But for now, we will use the defaultand then standardized option,which is go via a NAT gateway.So now our EKS cluster control plane service,we are connecting, means like work nodes.And then these cluster control planeis nothing but the master nodes, right?These are in communication using the NAT gateways.So the next thing is we are going to create our RDS databasein the same private subnet,or you can create two more private subnetsinto availability zone.And inside them also we can create.But what I have done is,I have leveraged the same private subnet,whatever EKS cluster control plane createdas part of cluster creation.So the same thing I have leveraged here.So now I have the RDS database here.The next thing is it's equivalent external name servicewe are going to create in this worker nodes,means like we are going to create external name serviceand then provide the Amazon RDS DB's endpoint URL for that,to send the traffic to this RDS DB.And next thing is we are goingto deploy our user management application.And then it will connectto the databases via external name service.So now here comes the classic load balancer.So this user management classic load balancer service,we'll create in the public subnet, right?And in addition to that,what happens is like, now whenever userstry to access the user management application,they use the classic ALB DNS URL, right?So this should be CLB DNS URL.I will change it.So using the CLB DNS URL, slash,your user MGM disk, slash, health status,whenever we access it,it comes to the classic load balancer.And from classic load balancer,the request gets distributed across different ports, right?So it will send to one part the request.And then once from port,it need to identify it's MySQL DB, right?So it will go to external name service.And then from external name service,it is going to connect to RDS DBand then get the data.So if we have any users created,then those users, we are going to access it.If no users got created, then we can go aheadand then create the user using the Postman project,whatever we have seen earlier.But on a high level,this is going to be the overall architecturewhich we are going to implement now.So to implement on a high level,what we are going to do is,currently our worker nodes are present in public subnet.So which we are going to delete them,and then create our worker nodes in the private subnetwhich is nothing but,we are going to create a EKS private node groupin private subnets.So as a step one, we are going to do that now.So I'll see you in the next lecture.Until then, bye bye.Thank you.