# 9.3 Step-03- Create Kubernetes ExternalName Service & Other Manifests, Deploy & Test

-: Welcome back.In previous lecture we have created our RDS database, right.So for our RDS database security group,if you see, it should have allow accesswhich we already provided it,we can crosscheck once if you want to, okay,so we can go here and the security group is this oneand you should have allow access from everywhere,so that's good.So we have crosschecked it, now we are goingto create a Kubernetes external name service manifestand then deploy it.So as usual it'll have a pay version kind metadataand then spec and the type of the servicewe are going to create is external nameand the external name valueis going to be whatever the value we have gotfrom RDS database endpoint information, okay,so if you go to RDS here and inside the database,so this is the information we are going to use,the endpoint information.So let me go back here and go to Visual Studio Codeand it is service and API is V1and under metadata nameand mySQL service name is mySQLand the spec...Inside spec, we'll have type and then external name.So first it is external name serviceand external name value, okayand external name value going to be whatever is presentfrom our RDS database endpoint, okay,so which is nothing but this one, right.So this is what we have copied, so this is good.So now we have createdthe mySQL external name service manifestso let's go ahead and then create that now.So this is the one, deploy this, manifest.So let's go to 06 e-Care storage's RDS DBand then say, kubectl,apply -F kube manifests S01 mySQL external name service.Right, so once it is created,so we can say kubectl get SVC,the mySQL service code created now.So the next step is to connect to that serviceand then create the database user MGMT schemainside that, Okay.So kubectl runs, so this is the kubectl client,whatever we are creating mySQL clientand just provide the host name of our thing, okay,so paste and -hatchand the whatever the host name we want to provide,we need to provide.So that we will take it from hereand then provide it, right.Paste and then still we have additional command herewhich is nothing but password,username and then password, okay.So copy and then paste it.So let's see what happens.So it got connected,so which means it connected to our mySQL database,which is in the private subnetsfrom our Qubernetes QCTL command line.So now we'll go ahead and then create the stuff,whatever is required.So we'll see initial schemas, whatever is provided,which is default schema should be available.Information schema, INO DB mySQL performance schema.So create a database user MGMT, okay.Right, so it got created.So now you can see, show schemasand you have the user MGMT got created.So now we can exit from here, Okay.Okay, so now we have exited.So now let's go backand then update the deployment file,username from route to DB admin.So if you see here,this is the user management microservice deployment,whatever we have brought it from our previous sectionsand here, you can see DB username.So earlier it is route,now we need to change it to DB admin.I already changed it for my previous testing.So in DB password, Kubernetes secret,we really didn't change anything here,it is going to be DB password 111,which we have given for our mySQL podand then here also if you want,if you have any doubt about it,so the 64 decode and then let's see what it is, okay.it should be DB password 11,right, it is DB password 11, so we should be good.So now let's go back,so this is the one which we need to update.If it is your previous manifest, whatever you have copiedand if you are using directly from here,from my course and in respect to this folder,then we really don't need to worry.So now we have completed the update step also.So let's move on and then deploy all the manifest, okay.So if you see here, 01 already createdwhich is unchangeable, which is mySQL service.So remaining things got createdwhich is rest top service, microserviceand then mySQL DB password, okay.So I'll say, kubectl get pods and it is coming up,it might take a while.So let's wait for it and if you want,we can even see the locks of this, okay.So tell the locks of this user management podand inside that container is only one container, right,so it started the application, okay,so which means it connected to the databaseand then it started the application.If you want to do additional check also, we can do now, why?Because we just created the schema.If you want, we can go thereand then check whether it has createdthe tables inside that, okay.So use user MGMT will connect to that respect to databaseand then I will say, show tables, right?So user's table is created, which means it is successful,my application got...My user management application started successfully.I'll say exit and I'll say, kubectl get pods,to see that one by one it is ready or not, so it is ready.So I'll say, kubectl get nodes -O wide,okay, so to get the public IP.So once we get the public IP,we know that our node port is going to be 31231 only.If you see here, 31231.So I'll take the public IP, copy,I'll go to the browser, new browser, STTP column,public IP of my worker nodeand 31231/user MGMT is the contextand health/status, okay,so it should be available now.We can see, it is up and running, rightand it's the same thing.So now we can go ahead and then delete the stuffand then clean up whatever we have createdas part of this RDS section.So we are not stopping the...We are not deleting this RDL database now, why?Because we are going to work on classic load balancers,network load balancersand then elastic application load balancersand then application load balancerrelated different, different featureslike context based routing,SSL redirect, port 80 to 443 redirectand then external DNS with route 53,all those Kubernetes manifest, we are going to write,if that is the case so we should not delete this,we are going to leverage thiswhich means like how many cloud serviceswe are going to use, that many,we are going to use as part of this Kubernetes thing.So one thing important here isif it is not in useor after this section you are going to breakand then you are going to see remaininglike just from tomorrowthen just go ahead and then stop itand whenever you're creating this database also,please ensure that whenever you selected mySQL hereand then you selected free tier here, okay.So if you really don't want any backups,so you can uncheck this option, okay.Whenever you are creating the database, okay.So already you have createdand now I am telling you about it,you can delete and then recreate itso that your backup costs are saved for you, okay.So it means like it is only a minor storage amountbut really don't worryor you can even go and then edit your databaseand then remove the backups also.So whatever the option is available for you,so you can say modify hereand just to save right table, the automated.So backup retention of 0 will disable the automated backupsand delete existing automated snapshotsof this DB instance, okay.So you can enable thisso that what happens is likeif you really don't want any of the backupsconsuming your spaceand then if this course takes longer daysfor you to complete and RDS database should be availablefor you to learn your other load balancer stuff also,we are going to.From here on, take RDS as our one of the backend databasefor our user management microservice application.So you can say, continueand then apply immediately and then modify that DB instance.So now let's go back here and then delete this stuff,qctl delete -F, and then kube manifests.So whatever we have created,we have deleted and then cleared that.So with that we have completed the RDS database section.So in our next lecture,we'll focus on classicand then network load balancers in 07.So I'll see you in the next lecture.Until then, bye bye, Thank you.