# 13.3 Step-03- Review Ingress CPR, Deploy and Verify

-: Welcome back.So let's go to the file04 ALB ingress context path based routing dot YAML,and let's define the ingress service here.So let's go back to our Visual Studio Code here.And we are in zero four ALB ingress context pathbased routing.So this template we have took from the0802 ALB ingress basics.So where we have written return 02 ALBingress basic with rules, we have copied thatand we have changed the way we need it.So the first thing, what we need to change here is,let's go back here to context path based routingand the name of my service, ingress CPR demo,context path based routing demo.And also the load balancer name we are going togive here is CPR ingress.And now let's come down hereand change these rules as per our needs, right?So the first things first is let me,we are going to implement three apps,app one app two and then, app three.So we'll put this as three times the paths,and the first path is app one.So for app one,it need to go to app one Nginx nodeport service.So if you want to verify the name of our nodeport service,go to zero one Nginx app one deploymentand this should be app one Nginx nodeport service.So let me close this,come back here and put the same thing here, right?And now the second one is app twoand for app two, the service name is going to beapp two Nginx nodeport service.So go to zero twoand get the name from here and come back here and put that.And for the root context, right,it is going to be app three.So let's go to zero three Nginx app threeand get the name of the nodeport service app threeNginx nodeport service, right?So let me put this here.So now you can see that for,whenever the request comes with slash app one,it goes to app one Nginx nodeport service.From there, it'll go to app one related podsand when request comes with slash app twoin the context path URL slash app two,so then it goes to app two Nginx nodeport serviceand from there it'll go to that respective pod,and same applies for app three Nginx nodeport service,anything other than app one or app two context,anything comes, so it goes toapp three Nginx nodeport service.So let's come back here and move on to the next step.Next step is to deploy all the manifest and test it.So let's go back to our terminal here,go into zero eight, new, right,which is zero eight new ELB application load balancers.And inside that, we are going inside 0803,which is ALB ingress context path based routing.And if you see here,we should have the kube manifest folder.And if you go inside and verify that,you should find 01, 02, 03 and then 04,04 is ALB ingress context path based routing YAML.So let's come out of this and then be inside 0803, right?And say kubectlapplyhyphen F and then kube manifest.So this should deploy three applicationsrelated deployments, nodeport servicesand also create a ingress service for us.So you can see app one Nginx deploymentand app one Nginx nodeport service is completedand app two Nginx deploymentand nodeport service is created,in same line, app three Nginx deploymentand app three Nginx nodeport service.And finally it also created the ingress CPRdemo related ingress service.So now let's come back here and verify the application podsand then nodeport services.So kubectl get ports should provide us the app one, app twoand then app three related Nginx pods created hereand one by one they are ready and then running, no issues.And we'll also verify the kubectl get SVC,so which is services and it should displayas the nodeport services, app one, app two and thenapp three.And now let's come back hereand verify the ingress load balancer related service.So we'll say, "Kubectl get ingress",and this should display the CPR ingressCPR demo related ingress serviceand it is using the ingress class, my AWS ingress class.And this is the address it has created,the load balancer DNS name with port 80.So let's go back here and if you want we can alsoreview the rules inside this respective ingress service.So we need to say kubectl, right,describeingress,and this is the ingress service name, ingress CPR demo.And let's see the rules, whatever we have implementedin our ingress service manifest were createdas expected or not.So you can see here slash app one goes toapp one Nginx nodeport service on port 80,and slash app two context path goes toapp two Nginx nodeport service,and slash goes to app three Nginx nodeport service.And we didn't define any default backend,so it's nothing here, right?So now let's come back hereand you can see successfully reconciledand there are no error events also here.And these are the annotationswhatever we have specified, those were displayed here.So now let's come back hereand verify the load balancer controller logs, right?So you can go here,kubectl hyphen n kube system get podswill provide us the load balancer controller.And if we want to review the logs also,we can review these things.Kubectl hyphen n kube system, right?And you can say logshyphen F.And for both the pods, you can verify the logsif there are any errors in those thingsbecause of the ingress service, whatever you have deployed.So we really don't need to do this,but it's forever additional learning.You can see here, registering the targets and so,and so, you can see all the logs in detailand understand little bit more, ideally not needed.So I'll remove this and I'll say, "Clear"and we'll go to verifying our application load balanceron AWS management console.So let's come back here and in EC2, let's go toload balancers,and load balancer CPR ingress,CPR ingress related load balancer is createdand in basic configuration, so you can find the DNS name.So this DNS name should match whatever we got here,which is kubectl get ingress, right,ingress and 1104311640,1104311640.So this is good.And state of the ingress service or theapplication load balancer is activewhich means we can access in the browser and test it.So we'll go to that a little bit later.First we'll go to the listeners and we can seethe port 80 listener is there,and under this listener,we will see the what all rules it has been defined.So you'll go here and you'll find somethinglike slash app one and whose priority is top most,the way how you define the priority is,slash app one will be the first priority.And, you can see it is going to some, forwardingto some app one Nginx related target groupand slash app two or slash app two slash starshould go to app two Nginx target groupand slash star goes to app three Nginx target group, right?So now let's come back hereand go to the target groups, right?And you should find three target groups, app one, app twoand then app three and all are using the nodeport servicewhich is nothing but whatever we have defined there.So let's open one of the target group and verify that.App one Nginx target group, right?So total, it has two targets which means, why,because we have a two worker nodes running.So those two worker nodes were registered herewith those respective nodeport servicesand then respective nodeport service.And you can see both, from bothof the nodes, it is healthy, the pod is healthy for us.And now if you see here, the health check pathshould be slash app one index dot HTML and,you can see it is healthy, right?Even though you have created only one pod,but the nodeport services span across all the nodes.So which means in the worker nodeswhenever you are using the nodeport service, right,so it is span across all the worker nodes in a,in a worker node group, you have created ten nodes.So those ten nodes will be registered herewith that respective nodeport service related port,which means even though you have created only one podand it is running in any one of the worker node,but the concept here is, nodeport service will be,or the service, Kubernetes service will bespanned across all the nodes.In that line, you can see here,all those nodes will be registered here.Now let's come back and verifyapp two related one and it's health check path.Those also healthy, both nodes registeredand you can come back here,and app two index dot HTML is the path for thatand it is working as expected.And this is the app three Nginx,which will be with root contact slash index dot HTMLand it is also healthy.So why we are verifying the health check paths herevery specifically is, so whatever we have definedat the service level annotation right,here health check path has been populated here successfullyor not in the ALB application load balancer,we are cross-checking.So why, because we said that we have definedthe context part based routing related ingress service,but we didn't define the health check path herebut we defined at the service level here,whether it came here successfully or not,we are cross-checking and it came successfully hereand we can see for all the three parts,whatever we define in the nodeport service annotations,so same is populated here.So now let's come back, right?So we verified the target groups,health check paths and everything.So now finally, we will go aheadand then access the application.So how we are going to access it?So we can take the DNS name from here,from the load balancer description hereor we can go here and copy this address.And for app one, it is going to be,we are going to say slash app one slash index dot HTML,and you can see it should be coming online now.So welcome to Stack Simplify and application name is app oneand app one is in light green color.So now we'll go to slash app two and index dot HTML.And this should show us app two related thingsand you can see, this is in different color.And now finally, we'll also accessthe root context slash index HTML, right?So whenever we access the route,so it should be the default app which iswelcome to Stack Simplify Kubernetes fundamentals demo,application version is V1.So this is app one.So this is app two under the app two contextand this is the default app three onewith the root context slash index dot HTML.And you can see all three are of three different colors.So the requests are going to three different apps for us.And if you want to further also verify,so you can go to kubectl get pods,and,for each port right, kubectl logs hyphen Fand then you can go to those pods and then verify the logs.Let's wait for it.And you can see slash app one index dot HTML,the health check path also using the same thing.So that's the reason you can see the, 190 to 168, 91.189,all these things are coming from our load balancer,right, here you can see, this is app one.So whenever you check the logs for your app one related pod,so it is saying 200 for app one index dot HTML.And if you see, for,kubectl get portsand if you check for app two,kubectl logs hyphen F and app two pod,you should see the health check for app two running there.So the logs for app two index dot HTML and it is also 200.And also we will say one more here,kubectlget pods, right?And we will also see for our app three which is,it should have the health check path for root context.So let's say logs hyphen F,and this is the app three Nginx pods.Come back here and verify thisand it should have slash index dot HTML,get slash index dot HTMLand it is coming from the ELB health checker.So this is the thing, and you can see one more here.This is not ELB health checker.So whenever we have accessed from the browser,so Intel, MacOS X10.15, which is my MacOS there,it has accessed and it is the public IP of my machine,124:123:166 dot three, right?So this is the thing.So this completes the use case, which is,implement the context path based routingusing ingress service and then test it, right?So in our next lecture, we are going totest the context path based routing order,how important is the defining the orderfor our context path based routing.So I'll see you in the next lecture.Until then, bye bye.Thank you.