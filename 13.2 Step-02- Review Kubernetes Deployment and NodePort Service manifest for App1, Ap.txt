# 13.2 Step-02- Review Kubernetes Deployment and NodePort Service manifest for App1, Ap

-: Welcome back.Let's go back to our GitHub repositoryand we are in section 0803 ELBingress context path-based routing.So as part of introductory section,we already discussed about the network architecturewhat we are going to implementand also the rules we are going to definefor app one, app two,and then app three.So as part of this process,we are also going to move our health check path annotationat the service level,which is nothing but inside the node port service.So why we need to do that is becausein the ingress service we can define a health check pathif it is common for all the servicesor all the applications,whatever you are load balancing.So, but per application,you have different health check path.Then that respective application health check path URLshould be configuredinside that respective node port service.So in that line we are going to move the health checkpath-related annotation to the node port serviceof that respective application,app one, app two,and then app three.And let's go back over step two here,which is review Nginx app one, app two,and app three deployment and then service.Service is nothing but the node port service.So let's go to our Visual Studio Code here,and we are in section 0803 ELBingress context path-based routing,and we are in 08 new ELB application load balancers,and inside that 0803,and in kube manifest folder we have 01, 02,and then 03 files.So 01 Nginx app one deployment and node port service,02 Nginx app two deployment and node port service,and 03 Nxinx app three deployment and node port service.And in app one deployment and node port service,so the standard deployment patternand standard node port service-related manifestswill be there here.Only differences, right?Only differences we are going to have here primarilyare related to Kubernetes deployment,which is container image name,and for Kubernetes node port service,the health check URL path.So let's come back here,and this is the app one Nginx deployment.And replicas, we are going to create one pod here.And the selector match labels,you have the app one Nginx as the label here,app equal to app one Nginx.So the same thing need to be defined in your node portservice-related selector app, app one Nginx.So now when you come to here in the image, right?In the port template spec, right?So stack simplifies slash kube Nginxapp one will be your app one-related Nginx image.And when you go to the node port service here,the health check path for app one isslash app one index.html.So this is the thing.So this is the one which we need to moveto those respective node port services.So need to add health check path annotationat service level if we are planning to use multiple targetsin a load balancer.So accordingly we have ensured thatfor the app one Nginx,we have added the health check pathin our node port service.So now if we go back to 02 Nginx deployment,so here also you'll see this is kube Nginx app twowill be my image here.And health check path also is slash app two index.html.And remaining things,which is nothing but this is app two Nginx,so its label, selector match label,will be app two Nginx,and it's a selector in the node port servicealso going to be app two Nginx, right?So now let's go back over 03 Nginx app three deployment.And if you see here the image name is kube Nginx.So this is a root context here.There is no specific context like slash app oneor slash app two inside this Nginx image.So it has a root context,and in the root context,you are going to have the index.html.So now let me also change this to app three.So everywhere you should see app three.So selector match labels, app three Nginx,and here also in the node port service alsoyou'll see selector,and the label is app and app three Nginx.And another important thing we need to cross-check hereis the health check path.So here we are going to check the root contactslash index.html as my health check pathfor my app three application.So these three are the applications we are going to deploy,and using ingress surveys, right?We are going to do the context path-based routing.So now let's come back here,and this completes the review of step two.In our next lecture,we are going to review step three,which is create ELB ingress contextpath-based routing Kubernetes manifest.So I'll see you in the next lecture.Until then, bye-bye.Thank you.