# 24.15 Step-15- [NEW] Deploy Stage- Test end to end Pipeline (Source, Build and Deploy)

Instructor: So, as part of step-08,we are going to test an end-to-end flow,wherein we are going to update or changeanything in our code and check in that codeand whether see that new version of codeis deployed or not, end to end, okay?So, now build and deploy stageswill be fired as part of this.So, let us go back to our Visual Studio Code,and we will go back to our aws-eks-devops.And in app1, index.html, we will say the version is V3.And we'll come to terminal,we'll come out of our eks-kubernetes-masterclass-relatedGitHub repo, and we will go to aws-eks-devops.And I will say git status.And one file is updated.So we will say git commit -am.And this is V3 commit.We will say V3 git push, we will say.And now, this change will be pushed.And if you go back here and try to refresh it here.So, this is the V3 one,and this is the bcdd4c2 is the commit code for this.And if you come back to the pipelines here,our source stage is using V3 version,you can see the V3 here.And even the build phase with bcdd4c2b as the source,it is trying to run the build phase.Once the build phase is run,it will also run the deploy phase.So let's wait for it.So now if we want, we can go here to Build projects.And go to Build projects,and go to build-eks-devops.This is deploy, we will need to verify the buildbecause currently build is in progress.So let's wait for it.Not sure why the first time it is failing, right?Sometimes, it will fail because of this docker thing.But anyway, that's fine.So let me come back here.And let us wait whether it is going to retry again or not.Build projects.And it is retrying again, right?So let us wait for it.And here, you can see running commandaws ecr get-login-password,and then docker login.So let us wait for it.Yes, login succeeded,and it is trying to build the docker image for us.And once it is built, it should be presentin our Elastic Container Registry.So this is the old commit code.Now, the new one also came just now, okay?So which is bcdd4c2.So if you see here, bcdd4c2.So we have successfully got that.Now, build phase is completedand it is moving to the deploy phase.So we will go ahead and then reviewthe deploy phase logs also in the deploy-eks-devops.So this is the thing that is running currently.And we will verify the logs, okay?Running echo install phase, nothing is present, right?It is going to the pre-build phaseand it is listing all the files.I have put one command here, ls -R and dot.Whether it is able to pick all the artifactsexported from the build phase or not,for that purpose I have put it.So it is saying that it got the buildspec-deploy.yml,it got the exports, exported-vars.env it got,and kube-manifest folder also it is there.And in kube-manifest folder,these 3 files are there, it is trying to say us, okay?Sourcing the environmental variables.So it is sourcing those environmental variables.And this is the IMAGE_URI,it is set now in this docker image,means like in this build file, where the build is running,in that build mission, it has set this IMAGE_URI.In IMAGE_TAG, you can see bcdd4c2.bcdd4c2.So that is good, okay?Now the next thing is running commandupdating container imagein the Kubernetes deployment YAML file.So in this WAML file, it is updating the container image.We said to cat that file so that we can verify.So we can see it has updated successfullyfor DevOps pipeline.Actually what will be present in the source,source, if you go here, it will have container image.With this said command, whatever we have provided.Using this command, it has replaced the container imagewith IMAGE_TAG, $IMAGE_URI:$IMAGE_TAG.So that is also successful, okay?So now, we are entering the build phase.In build phase, running command assuming IAM roleto access EKS cluster.So this is very, very important, okay?So running command, it is trying to assume the role,whatever we have provided.So what is the role we have provided?In the variable section, we should see, right?It should be the same one, okay?So in the deploy,you can see this is the role we have provided,and it is the same thing, okay?Right? And update now, let us come down.And it is setting up all the environmental variablesand updating kubeconfig with EKS cluster.So kubeconfig is completed, right?And then, it also said kubectl apply -f kube-manifest.So it has deployed these things,and waiting for the deployment rollout to complete.So which means it will say that kubectl rollout status,and then it will run this command.And all the rollout meanslike all the deployment is successful.And see build state is succeeded.Moving to the post-build state here.And in the post-build state,it has run kubectl get pods -o wide,and these are the eks-devops-deployment-related things,which are in the running state.And after that, it has also run the kubectl get svc -o wide.EKS nodeport-service is there.And then it is also running the ingress one.So this is the ingress service.It has run, okay?So it is currently getting created, maybe.So we have successfully verified,means like whatever the end-to-end flow, right?So if you see, source, build, and deploy,all three things are working fine, okay?So it has successfully deployed.Now, the thing is we need to verify some more things, right?So now, let us come back here, okay?And clear.We will say kubectl get ingress.And ingress service is created.If you want, we can go to EC2 hereand go to the load balancer here.So we will go to Load Balancers,and our application load balancer should be created now,and it should be in the active state.And in addition to that, if you want,we can also go to Route 53and search for the DNS names, okay?So what is the DNS names we have configured?It is eksdevops, okay? 1 and 2.Okay, so we will go to Hosted zones.And we will go to stacksimplify.com.And here, we will search for eksdevops.And you can see for eksdevops1 and 2, it has created.See 1 and eksdevops2,which means we should be able to access our application now.So we can say incognito window,and then /app1/index.html, right?And see V3 version of our application is running.If you want, you can also say eksdevops1.And for 1 also, /app1/index.html, okay?And it should be also accessible V3.So that is about what we call end-to-end test, okay?Let me close this. What is this?This one, I will try to close. Yeah.And come back.And come back here.And if you want to try one more time,one more end-to-end test if you want to try,you can even try it.We will try it one more time,another 2 minutes, what is wrong here, right?We are not going to verify anything,only access our application and then verify.So we will come back here.In index.html, we will change this to V4, right?And next is, we will say git status.git commit -am.And this is V4 version, okay?And git push.And now, the source in the pipeline,earlier it is V3, now it should kick in with V4.So let us wait for it, it should kick in with V4.See V4 is kicked in.And source is completed, build phase is running,after that, it should also run the deploy phase.So let us wait for the deploy phase,and after that, when we try to access our application,instead of this V3, we should see V4 here.So that is what we are trying to verify.So once this end-to-end test 2 is completed,in our next lecture,we will focus on adding the approval stageand all those things we are going to add.So let us wait for it, okay?So we can see it here for source V4,and also for build V4, and also for deploy also V4,which means, as part of V4 version,source, build, and deploy, all 3 stages were successful.So we will go back here and try to refresh our page here.Try to refresh it.And see V4 application is coming.So which means we are successful in implementingthe eks-devops-pipeline using CodePipelineand then CodeBuild.In our next lecture,we will focus on implementing a manual approval stage here.I will see you in the next lecture.Until then, bye-bye. Thank you.